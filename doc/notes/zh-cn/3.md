# 3. 对象

[返回目录](index.md)

---

有意思的东西，实现起来相对没有那么复杂，难的东西都被安插在前面了。

<br/>

`Object`类的设计思路
---

`Object`类保有指示类型的`Type`对象，以及负责内存管理（可能不完全是）的`ObjectData`辅助类。其中`Type`对象负责解释内存中的数据分布。尽管名为“Object”，但是它不是仅能持有类对象，也能持有非类对象，甚至是并非对象的引用（为了和前面的接口统一，只能做出小小牺牲了）。它的职能极其简单，几乎只有包装和转发请求，所以不必派生。

<br/>

`ObjectData`如何设计
---

但是`ObjectData`需要派生，影响其设计的因素太多了，包括但不限于端序、存储方式、内存映射等（不过这些有谁控制我之后可能会另行安排）。此外不得不考虑的一点就是子对象的问题。不过，由于子对象是完整的对象，因此和不是子对象的对象基本没有什么区别，比较容易解决。子对象，还有包括像数组元素之类的存在，我们可以用一个`ObjectData`的拓展了内存映射功能的派生类来解决。


<br/>

不得不引入新的类
---

解决了内存和数据解释的问题，接下来要做生存期相关的内容。生存期的控制如何实现我暂时没有思路，可能要专门设计一个`Lifetime`类来管理。此外，`Lifetime`常常要和作用域绑定，因此引入`Scope`作用域类，然后又可能不得不引入`Stack`堆栈类管理内存。不过可以仅仅实现一个`FreeLifetime`模拟由`new`/`delete`管理的自由存储对象（假装我们用的是吧）。

<br/>

`ObjectList`和可能要加上的`Arguments`类
---

`ObjectList`统筹管理一群对象，它拓展了`std::vector`的功能，会选择公开继承、私有继承或者包含的其中一种方式，等我斟酌。提供方便的结构化绑定，方便native函数提取参数（也许会设计`Argument`类来作为参数包？谁知道要不要呢，走一步看一步）。

<br/>


已有的4篇笔记让它的雏形越来越明确，挺好的.

---

<sub>
写于2023/8/26
</sub>
